// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createAnswer = `-- name: CreateAnswer :one
INSERT INTO game_answers (game_id, player_id, game_question_id, option_id, answered_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id, game_id, player_id, game_question_id, option_id, answered_at
`

type CreateAnswerParams struct {
	GameID         string
	PlayerID       int64
	GameQuestionID int64
	OptionID       int64
}

func (q *Queries) CreateAnswer(ctx context.Context, arg CreateAnswerParams) (GameAnswer, error) {
	row := q.db.QueryRowContext(ctx, createAnswer,
		arg.GameID,
		arg.PlayerID,
		arg.GameQuestionID,
		arg.OptionID,
	)
	var i GameAnswer
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.PlayerID,
		&i.GameQuestionID,
		&i.OptionID,
		&i.AnsweredAt,
	)
	return i, err
}

const createGame = `-- name: CreateGame :one
INSERT INTO games (id, quiz_id)
VALUES (?, ?)
RETURNING id, quiz_id, created_at, started_at
`

type CreateGameParams struct {
	ID     string
	QuizID int64
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.ID, arg.QuizID)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.CreatedAt,
		&i.StartedAt,
	)
	return i, err
}

const createGameQuestion = `-- name: CreateGameQuestion :one
INSERT INTO game_questions (game_id, question_id, started_at, expired_at)
VALUES (?, ?, ?, ?)
RETURNING id, game_id, question_id, started_at, expired_at
`

type CreateGameQuestionParams struct {
	GameID     string
	QuestionID int64
	StartedAt  time.Time
	ExpiredAt  time.Time
}

func (q *Queries) CreateGameQuestion(ctx context.Context, arg CreateGameQuestionParams) (GameQuestion, error) {
	row := q.db.QueryRowContext(ctx, createGameQuestion,
		arg.GameID,
		arg.QuestionID,
		arg.StartedAt,
		arg.ExpiredAt,
	)
	var i GameQuestion
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.QuestionID,
		&i.StartedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const createParticipant = `-- name: CreateParticipant :one
INSERT INTO game_participants (game_id, player_id)
VALUES (?, ?)
RETURNING id, game_id, player_id, joined_at
`

type CreateParticipantParams struct {
	GameID   string
	PlayerID int64
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (GameParticipant, error) {
	row := q.db.QueryRowContext(ctx, createParticipant, arg.GameID, arg.PlayerID)
	var i GameParticipant
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.PlayerID,
		&i.JoinedAt,
	)
	return i, err
}

const getGame = `-- name: GetGame :one
SELECT id, quiz_id, created_at, started_at
FROM games
WHERE id = ?
`

func (q *Queries) GetGame(ctx context.Context, id string) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.CreatedAt,
		&i.StartedAt,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, username, email, created_at
FROM players
WHERE id = ?
`

func (q *Queries) GetPlayer(ctx context.Context, id int64) (Player, error) {
	row := q.db.QueryRowContext(ctx, getPlayer, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const listAnswersByGameQuestionID = `-- name: ListAnswersByGameQuestionID :many
SELECT id, game_id, player_id, game_question_id, option_id, answered_at
FROM game_answers
WHERE game_question_id = ?
`

func (q *Queries) ListAnswersByGameQuestionID(ctx context.Context, gameQuestionID int64) ([]GameAnswer, error) {
	rows, err := q.db.QueryContext(ctx, listAnswersByGameQuestionID, gameQuestionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameAnswer
	for rows.Next() {
		var i GameAnswer
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.PlayerID,
			&i.GameQuestionID,
			&i.OptionID,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameQuestionsByGameID = `-- name: ListGameQuestionsByGameID :many
SELECT id, game_id, question_id, started_at, expired_at
FROM game_questions
WHERE game_id = ?
`

func (q *Queries) ListGameQuestionsByGameID(ctx context.Context, gameID string) ([]GameQuestion, error) {
	rows, err := q.db.QueryContext(ctx, listGameQuestionsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameQuestion
	for rows.Next() {
		var i GameQuestion
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.QuestionID,
			&i.StartedAt,
			&i.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParticipantsByGameID = `-- name: ListParticipantsByGameID :many
SELECT id, game_id, player_id, joined_at
FROM game_participants
WHERE game_id = ?
`

func (q *Queries) ListParticipantsByGameID(ctx context.Context, gameID string) ([]GameParticipant, error) {
	rows, err := q.db.QueryContext(ctx, listParticipantsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameParticipant
	for rows.Next() {
		var i GameParticipant
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.PlayerID,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startGame = `-- name: StartGame :execresult
UPDATE games
SET started_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) StartGame(ctx context.Context, id string) (sql.Result, error) {
	return q.db.ExecContext(ctx, startGame, id)
}
